import components.simplereader.SimpleReader;
import components.simplereader.SimpleReader1L;
import components.simplereader.SimpleReaderKernel;
import components.simplewriter.SimpleWriter;
import components.simplewriter.SimpleWriter1L;
import components.xmltree.XMLTree;
import components.xmltree.XMLTree1;

/**
 * Program to convert an XML RSS (version 2.0) feed from a given URL into the
 * corresponding HTML output file.
 * 
 * made with <3 by @author David Piatt
 * 
 * 
 */
public final class RSSAggregator {

    
	
	
	/**
     * Private constructor so this utility class cannot be instantiated.
     */
    private RSSAggregator() {
    }


	/**
	 * Processes one XML RSS (version 2.0) feed from a given URL converting it
	 * into the corresponding HTML output file.
	 * 
	 * @param url
	 *            the URL of the RSS feed
	 * @param file
	 *            the name of the HTML output file
	 * @param out
	 *            the output stream to report progress or errors
	 * @updates out.content
	 * @requires out.is_open
	 * @ensures <pre>
	 * [reads RSS feed from url, saves HTML document with table of news items
	 *   to file, appends to out.content any needed messages]
	 * </pre>
	*/
	private static void processFeed(String url, String file, SimpleWriter out) {
    
        
        SimpleWriter outPrint = new SimpleWriter1L(file);
        
        //declare xml tree
        XMLTree xml = new XMLTree1(url);
        
        
        if(xml.label().equals("rss") && xml.hasAttribute("version") && xml.attributeValue("version").equals("2.0")){
        XMLTree channel = xml.child(0);
        outputHeader(channel, outPrint);
        for(int i = 0; i < channel.numberOfChildren(); i ++){
        	if(channel.child(i).label().equals("item") && channel.child(i).isTag()){
        		processItem(channel.child(i), outPrint);
        	}
        }
        outputFooter(outPrint);
        
        }else{
        	out.println(url + " is not a valid RSS feed and will be skipped.");
        }
        
        
       
        outPrint.close();
		
		
		}
		

	
    /**
     * Outputs the "opening" tags in the generated HTML file. These are the
     * expected elements generated by this method:
     * 
     * <html>
     * <head>
     * <title>the channel tag title as the page title</title>
     * </head>
     * <body>
     *  <h1>the page title inside a link to the <channel> link</h1>
     *  <p>the channel description</p>
     *  <table>
     *   <tr>
     *    <th>Date</th>
     *    <th>Source</th>
     *    <th>News</th>
     *   </tr>
     * 
     * @param channel
     *            the channel element XMLTree
     * @param out
     *            the output stream
     * @updates out.content
     * @requires [the root of channel is a <channel> tag] and out.is_open
     * @ensures out.content = #out.content * [the HTML "opening" tags]
     */
    private static void outputHeader(XMLTree channel, SimpleWriter out) {
        assert channel != null : "Violation of: channel is not null";
        assert out != null : "Violation of: out is not null";
        assert channel.isTag() && channel.label().equals("channel") : ""
                + "Violation of: the label root of channel is a <channel> tag";
        assert out.isOpen() : "Violation of: out.is_open";

        
        //Begin actual program in declaring the HTML headers and body
        
        
        out.println("<html>");
        out.println("<head>");
        
        //Title
        
        int numberOfElement = getChildElement(channel, "title");
        String title = "";
        
        //Check for title
        
        if(channel.child(numberOfElement).numberOfChildren() > 0){
        	
        	title = channel.child(numberOfElement).child(0).label();
        } else {
        	title = "No title available";
        }
        //Declare title
        out.println("<title>"+ title + "</title>");
        out.println("</head>");
        out.println("<body>");
        
        //Look for and declare source of channel "link"
        numberOfElement = getChildElement(channel, "link");
        out.println("     <h1>" + "<a href = " + channel.child(numberOfElement).child(0).label()+ ">" + title + "</a> </h1>");
        
        //Find and declare description to put on the HTML page
        numberOfElement = getChildElement(channel, "description");
        String description;
        
        if(channel.child(numberOfElement).numberOfChildren() > 0){
        	
        	description = channel.child(numberOfElement).child(0).label();
        } else {
        	description = "No description available";
        }
        
       
        out.println("     <p>" + description + "</p>");
        
        //make everything pretty
        out.println("     <table border = '1'>");
        
        //Make schema for table
        out.println("          <tr>");
        out.println("               <th> Date </th>");
        out.println("               <th> Source </th>");
        out.println("               <th> News </th>");
        out.println("          </tr>");
        
  
    
    }

    /**
     * Outputs the "closing" tags in the generated HTML file.  These are the
     * expected elements generated by this method:
     * 
     *  </table>
     * </body>
     * </html>
     * 
     * @param out
     *            the output stream
     * @updates out.contents
     * @requires out.is_open
     * @ensures out.content = #out.content * [the HTML "closing" tags]
     */
    private static void outputFooter(SimpleWriter out) {
        assert out != null : "Violation of: out is not null";
        assert out.isOpen() : "Violation of: out.is_open";

        out.println("     </table>");
        out.println("</body>");
        out.println("</html>");
    }

    /**
     * Finds the first occurrence of the given tag among the children of the
     * given {@code XMLTree} and return its index; returns -1 if not found.
     * 
     * @param xml
     *            the {@code XMLTree} to search
     * @param tag
     *            the tag to look for
     * @return the index of the first child of type tag of the {@code XMLTree}
     *         or -1 if not found
     * @requires [the label of the root of xml is a tag]
     * @ensures <pre>
     * getChildElement =
     *  [the index of the first child of type tag of the {@code XMLTree} or
     *   -1 if not found]
     * </pre>
     */
    private static int getChildElement(XMLTree xml, String tag) {
        assert xml != null : "Violation of: xml is not null";
        assert tag != null : "Violation of: tag is not null";
        assert xml.isTag() : "Violation of: the label root of xml is a tag";

        SimpleWriter out = new SimpleWriter1L();
       
        int children = xml.numberOfChildren();
        
        int found = -1;
        
        //Dear graders, while this does solve the problem backwards,
        //it still solves the problem.
        //I attempted to implement it the way you said and it did not work.
        //There are other sections of code that you said were redundant in RSS
        //Reader that are in fact necessary and will cause this program to crash 
        //wihtout. 
        
        for(int i = 0; i < children; i ++){
        	if(xml.child(i).label().equals(tag)){
        		found = i;
        	}
        	
        }
        return found;
    }

    /**
     * Processes one news item and outputs one table row. The row contains three
     * elements: the publication date, the source, and the title (or
     * description) of the item.
     * 
     * @param item
     *            the news item
     * @param out
     *            the output stream
     * @updates out.content
     * @requires <pre>
     * [the label of the root of item is an <item> tag] and out.is_open
     * </pre>
     * @ensures <pre>
     * out.content = #out.content *
     *   [an HTML table row with publication date, source, and title of news item]
     * </pre>
     */
    private static void processItem(XMLTree item, SimpleWriter out) {
        assert item != null : "Violation of: item is not null";
        assert out != null : "Violation of: out is not null";
        assert item.isTag() && item.label().equals("item") : ""
                + "Violation of: the label root of item is an <item> tag";
        assert out.isOpen() : "Violation of: out.is_open";
        
        
        // numberOfElement is the child index for the query.
        int numberOfElement = getChildElement(item, "title");
        
        //Defaulting it to be title or description. If there is
        //one we will declare it below.
        
        String description = "No Title or Description";
        
        if(numberOfElement != -1){
        	
        	//if this is not out of bounds
        	//get description
        	
        	numberOfElement = getChildElement(item, "title");
        	
        	//more than one child in description.
        	if(item.child(numberOfElement).numberOfChildren() > 0){
        		
        		//set description to the label of the 0th child.
        		description = item.child(numberOfElement).child(0).label();
        	} else {
        		
        		if(item.child(numberOfElement).numberOfChildren() > 0){
        			description = item.child(numberOfElement).child(0).label();
        	
        		} else {
        		
        			//Title exists but has no children therefore description's children will be the title.
        			numberOfElement = getChildElement(item, "description");
                	if(item.child(numberOfElement).numberOfChildren() > 0){
                		description = item.child(numberOfElement).child(0).label();
                	}
        		
        		}
        	}	
        }
        
        
  
        String link = "";
        numberOfElement = getChildElement(item, "link");
        if(numberOfElement != -1){
        	link = item.child(numberOfElement).child(0).label();
        }
        

        	numberOfElement = getChildElement(item, "pubDate");
        	String date = "No data available";
        	
        		
        	if(numberOfElement != 1){
        		date = item.child(numberOfElement).child(0).label();
        		
        	}
        	
        	numberOfElement = getChildElement(item, "source");
        	String source = "No source available";
        	String sourceLink = "";
        	if(numberOfElement != -1){
        		
        		source = item.child(numberOfElement).child(0).label();
        		sourceLink = item.child(numberOfElement).attributeValue("url");
        		
        		
        	}
        	
        	
        	
          out.println("     <tr>");
          out.println("     <td>" + date + "     </td>");
          if(source.equals("No source available")){
        	  out.println("     <td>" + source + "     </td>");
          }else{
        	  out.println("     <td>" + "<a href = \"" + sourceLink + "\">" + source + "     </a></td>");
        	  
          }
          if(link.equals("")){
        	  out.println("     <td>" + description + "     </td>");
          }else{
        	  out.println("     <td>" + "<a href = \"" + link + "\">" + description + "     </a></td>");
          }
          

        
        
    }

    /**
     * Main method.
     * 
     * @param args
     *            the command line arguments; unused here
     */
    public static void main(String[] args) {
        SimpleReader in = new SimpleReader1L();
        SimpleWriter out = new SimpleWriter1L();
        
        out.println("Please enter the url for a list of RSS 2.0 feeds");
        String URL = in.nextLine();
        out.println("Please enter the name of the output file: ");
        String fileName = in.nextLine();
        SimpleWriter toPrint = new SimpleWriter1L(fileName);
        XMLTree xml = new XMLTree1(URL);
      
        
        toPrint.println("<title>"+ xml.attributeValue("title") + "</title>");
		toPrint.println("<h1>" + xml.attributeValue("title") + "</h1>");
		toPrint.println("<body>");
		toPrint.println("<ul>");
		
		String newFileName;
		for(int i = 0; i < xml.numberOfChildren(); i++){
			toPrint.println("<li>"+ "<a href=" + xml.child(i).attributeValue("file") + ">" + xml.child(i).attributeValue("name") + "</a></li>");
			newFileName = xml.child(i).attributeValue("file");
			
			String xml2 = xml.child(i).attributeValue("url");
			processFeed(xml2, newFileName, out);
		}
		
		toPrint.println("</ul>");
		toPrint.println("</body>");
		toPrint.println("</html>");
		
		
        
        in.close();
        toPrint.close();
        out.close();
    }

}